{"name":"mHealthDroid","tagline":"A biomedical mobile framework for rapid development of mHealth applications in Android","body":"<img src=\"http://apuestasrafag.files.wordpress.com/2014/03/fotologo2.png?w=712\" height=225>\r\n\r\n## What is mHealthDroid?  \r\n\r\nmHealhDroid is an open-source mobile framework designed to facilitate the rapid and easy development of mHealth and biomedical applications. The framework is devised to leverage the potential of mobile devices such as smartphones or tablets, wearable sensors and portable biomedical devices. These systems are used increasingly for the monitoring and delivery of personal health care and wellbeing. Likewise, mHealthDroid aims at bringing together heterogeneous multimodal sensors including both research and commercial systems. \r\n\r\nThe framework comprises an extensive set of modules for sensor data acquisition, data management, remote storage, signal processing, machine learning, multidimensional data visualization, as well as intelligent recommendations and multimedia guidelines among others features. The core of the framework is defined to operate on the Android operating system; however, it has been implemented in a way that allows its use with any portable device. In fact, the core modules and components are defined to be completely independent of the underlying sensing and communication technology. To utilize a new device (commercial or not) it is only required to include the corresponding drivers that allow the communication between the mHealthDroid modules and the specific device (transparent to the user anyhow). The mHealthDroid initiative already includes drivers for a wide sort of portable devices; nevertheless it aims at incorporating new systems to the current portfolio of supported devices. \r\n\r\nThis active platform is in continuous development, thereby contributions are very welcome. Suggestions and comments are also appreciated!\r\n\r\nContact (general info): mhealthdroid@gmail.com\r\n\r\nContact (R&D enquiries): oresti.bl@gmail.com [<a href=\"http://www.ugr.es/~oresti/\">Oresti Baños</a>]\r\n\r\nContact (implementation enquiries): rafagarfer@gmail.com [Rafael García], alejandrosaez3@gmail.com [Alejandro Sáez] \r\n\r\n**Table of Contents**\r\n\r\n- [What is mHealthDroid?](#what-is-mhealthdroid)\r\n- [Features. What does mHealthDroid offer me?](#features-what-does-mhealthdroid-offer-me)\r\n- [Installation instructions](#installation-instructions)\r\n- [mHealthDroid structure](#mhealthdroid-structure)\r\n- [Full documentation](#full-documentation)\r\n- [APP examples](#app-examples)\r\n- [How to use mHealthDroid](#examples-how-to-use-mhealthdroid)\r\n- [Contribution guidelines](#contribution-guidelines)\r\n- [Community](#community)\r\n- [Team Members](#team-members)\r\n- [Where can I get help?](#where-can-i-get-help)\r\n- [Inspiration](#inspiration)\r\n- [Copyright and license](#copyright-and-license)\r\n\r\n## Features. What does mHealthDroid offer me?\r\n\r\n* Rapid development of medical, health and wellbeing applications.\r\n\r\n* Fast and efficient communication between portable biomedical devices and portable mobile devices to gather human-centered physiological and kinematic data. Up to now, SHIMMER biomedical devices and mobile sensors can be used as portable biomedical devices.\r\n\r\n* Development of applications capable of working with different portable health devices simultaneously.\r\n\r\n* Efficient data transfer across the framework's managers.\r\n\r\n* Fast data storage (either local or remote).\r\n\r\n* Visualization of any multimodal data streams such as patient's vital signs or kinematic data (either online or offine).\r\n\r\n* Knowledge inference by using machine learning and pattern recognition models.\r\n\r\n* Multimedia guidelines and recommenders, supported through audio, video and YouTube playlists, as well as notification procedures.\r\n\r\n* System control and configuration tools to manage WiFi, 3G, Bluetooth, screen brightness, phone calls or text messages.\r\n\r\n* User logging and data privacy mechanisms\r\n\r\n## Installation instructions\r\n\r\nA few steps are required to get started:\r\n\r\n1. Download the project source files.\r\n\r\n2. Import the project to Eclipse or other IDE.    \r\n\r\n3. Add the following libraries:\r\n\r\n    - GraphView 3.0.jar\r\n    - Guava 14.0.jar\r\n    - Shimmer.jar\r\n    - WekaSTRIPPED.jar\r\n    - YouTubeAndroidPlayerApi.jar\r\n\r\n4. Select mHealthDroid as library project.\r\n\r\n5. Create your new project and select mHealthDroid as library. \r\n\r\n6. Coding time!\r\n\r\nAll the libraries can be downloaded from mHealthDroid´s releases.\r\n\r\nhttps://github.com/mHealthDroid/mHealthDroid/releases\r\n\r\n## mHealthDroid structure\r\n\r\n<img src=http://apuestasrafag.files.wordpress.com/2014/03/frameworkdiagram.png?w=800 />\r\n\r\nThe figure above depicts the structure of the framework, including all the existing managers and how they interact with each other. All these managers are of \"singleton\" kind, which means that only one unique instance can exist for each class and this instance is available from every component of the framework. In the following we provide a brief description of each manager. \r\n\r\n- **Communication Manager**: it is responsible for the connection of mobile devices (smartphone, tablet) and biomedical devices, vital data gathering, local data storage and serve the collected data to the rest of the framework components.\r\n- **Remote Storage Manager**: it is devised to upload the data avalaible in the local database to a remote storage. Although the framework only comprises the client side of the communication, we provide along with the framework a possible implementation for the server side.\r\n- **Visualization Manager**: it supports both online and offline visualization. It builds on an original extension of the GraphView library (http://android-graphview.org/). The source code of the new version developed as part of the _mHealthDroid_ project can be found at https://github.com/mHealthDroid/myGraphView.\r\n- **Data Processing Manager**: it is in charge of supervising and coordinating all the processes related to the inference of knowledge. This manager provides signal processing, data mining and machine learning techniques to extract knowledge from the biomedical data.\r\n- **System Manager**: this is a miscellaneous manager which allows for the configuration and monitoring of instrinsic aspects of the mobile and external devices. More importantly, it comprises a set of tools to support guidelines, recommendations or alerts of worth in health applications.\r\n\r\n## Full documentation\r\n\r\nThe mHealthDroid full documentation can be found in <a href=\"http://apuestasrafag.files.wordpress.com/2014/02/full-documentation-thesis-rafael-garcia.pdf\">Rafael's</a> and <a href=\"http://apuestasrafag.files.wordpress.com/2014/02/full-documentation-thesis-alejandro-saez.pdf\">Alejandro's</a>  Master Thesis.\r\n\r\n## APP examples\r\n\r\n- mHealthAPP: exemplary APP intended to show the usefulness and potential of mHealthDroid. More information in <a href=\"https://github.com/mHealthDroid/mHealthAPP\">mHealthAPP </a>repository\r\n\r\n[<img src=\"http://apuestasrafag.files.wordpress.com/2014/03/thumbnailvideo.png?w=673\" height=300>](https://www.youtube.com/watch?v=AMdxw4osjCU)\r\n\r\n\r\n## Examples. How to use mHealthDroid\r\n\r\nThe aim of this section is to show basic examples of how to use each manager.\r\n\r\n### Communication Manager\r\n\r\nEvery manager is singleton, which means it is necessary to get its instance like this:\r\n\r\n``` java\r\nCommunicationManager cm = CommunicationManager.getInstance();\r\n```\r\nThen, if one wants to storage data into the database, the variable storage must be initialized this way:\r\n\r\n``` java\r\ncm.CreateStorage(getApplicationContext());\r\n\r\n```\r\n\r\nTo add devices to the manager, one just needs to call the appropriate functions:\r\n\r\n``` java\r\ncm.AddDeviceShimmer(getApplicationContext(), \"Device Shimmer\", true);\r\ncm.AddDeviceMobile(getApplicationContext(), \"Mobile Device\");\r\n```\r\n\r\nSince the mobile device uses the device's sensor, it is not necessary to connect it. But\r\nfor the Shimmer devices, once they have been added, they need to be connected. This\r\nwork is done by the function _Connect_, giving as parameter the mac address:\r\n\r\n``` java\r\ncm.connect(\"Device Shimmer\", address);\r\n```\r\n\r\nBefore the device starts to stream, the enabled sensors of the devices can be set:\r\n\r\n``` java\r\nArrayList<SensorType> sensors = newArrayList<SensorType>();\r\nsensors.add(SensorType.ACCELEROMETER);\r\nsensors.add(SensorType.MAGNETOMETER);\r\nsensors.add(SensorType.GYROSCOPE);\r\ncm.writeEnabledSensors(\"Mobile Device\", sensors);\r\ncm.writeEnabledSensors(\"Device Shimmer\", sensors);\r\n```\r\n\r\nThe number of samples to be stored in the buffer can be chosen too:\r\n\r\n``` java\r\ncm.setNumberOfSampleToStorage(100);\r\n```\r\n\r\nAfter all these things are done, it is the suitable moment to start (and stop whenever\r\nis wanted) to stream:\r\n\r\n``` java\r\ncm.startStreaming(\"Mobile Device\");\r\ncm.startStreaming(\"Device Shimmer\");\r\ncm.stopStreaming(\"Mobile Device\");\r\ncm.stopStreaming(\"Device Shimmer\");\r\n``` \r\n\r\nThere are a couple of features that can be set either before or during the data streaming\r\nsuch as to select what device is going to store its data (by default, it is set to true) or to set a label.\r\n\r\n``` java\r\ncm.setStoreData(\"Mobile Device\", false);\r\ncm.setStoreData(\"device Shimmer\", true);\r\ncm.setLabel(\"walking\");\r\n```\r\n\r\nThere is a way to get the device in case it is wanted to access to its specific functionalities:\r\n\r\n``` java\r\nDeviceShimmerdS = (DeviceShimmer) cm.getDevice(\"Device Shimmer\");\r\nDeviceMobiledM = (DeviceMobile) cm.getDevice(\"Mobile Device\");\r\n```\r\n\r\nTo insert a new users profile there are a couple of things to consider. The database\r\nmust be open and the table created. It is also possible to check whether the login\r\nalready exists in order to avoid a SQL exception. Then the database should be closed.\r\nAll of this is possible by doing:\r\n\r\n``` java\r\ncm.openDatabase();\r\ncm.createUsersTable();\r\nif(!cm.existsLogin(login))\r\n\tcm.addUserProfile(login, password, age, sex, weight, height, email);\r\nelse\r\n\tToast.makeText(getApplicationContext(), \"this login already exists\",Toast.LENGTH_SHORT).show();\r\ncm.closeDatabase();\r\n```\r\nIn case there are devices streaming, it is advisable to check whether any of them store\r\ndata before closing the database. It should be done in order to avoid a SQL exception.\r\nTo do that, it is only necessary to call the function of the Communication Manager\r\nnamed _isStoring()_:\r\n``` java\r\nif(!cm.isStoring())\r\n\tcm.closeDatabase();\r\n```\r\n\r\n### Remote Storage Manager\r\n\r\nThe way to use this module is quite simple. RemoteStorageManager is a singleton class (class instantiation restricted to one object), so to obtain a RemoteStorageManager instance is necessary to proceed as follows:\r\n\r\n``` java\r\nServerManager sm = ServerManager.getInstance();\r\n```\r\n\r\nIt is also necessary to initialize the Storage variable belonging to the RemoteStorageManager class called storage. This is done by:\r\n\r\n``` java\r\nsm.CreateStorage(getApplicationContext());\r\n```\r\n\r\nThen the server IP address is set by means of the function _setServerIP_. Also, it\r\nis compulsory to set the name and path (if necessary) of the scripts that will be executed in the server side. These scripts must be accessible from the server IP address.\r\nFor example, using XAMPP like in this example the scripts inside the _Htdocs_ can be\r\naccessible by the address _http://serverIP/scriptName_.\r\n\r\n``` java\r\nsm.setServerIP(\"http://192.168.1.11\");\r\nsm.setMobileMetadataPath(\"insert_mobile_metadata.php\");\r\nsm.setMobileSignalsPath(\"insert_mobile_signals.php\");\r\nsm.setMobileUnitsPath(\"insert_mobile_units.php\");\r\nsm.setShimmerMetadataPath(\"insert_shimmer_metadata.php\");\r\nsm.setShimmerSignalsPath(\"insert_shimmer_signals.php\");\r\nsm.setShimmerUnitsPath(\"insert_shimmer_units.php\");\r\nsm.setLastIDPath(\"get_last_ID.php\");\r\n```\r\n\r\nIf WiFi connection is used, WiFi must be enabled. The user can turn it on through\r\nthe setWiFiEnabled function defined on the System Manager.\r\n\r\n``` java\r\nsysm.setWifiEnabled(true, getApplicationContext());\r\n```\r\n\r\nThere are three functions for uploading, one for each database table: data, metadata\r\nor units. For example, the uploading of the the database tables for the mobile device\r\n(\"Mobile device\") and the ones for a given wearable monitoring device (\"device 1\") is\r\ndefined as follows:\r\n\r\n``` java\r\n// To upload shimmer tables\r\nsm.uploadUnitsTable(\"device 1\");\r\nsm.uploadMetadataTable(\"device 1\");\r\nsm.uploadSignalsTable(\"device 1\");\r\n\r\n// To upload mobile tables\r\nsm.uploadUnitsTable(\"Mobile Device\");\r\nsm.uploadMetadataTable(\"Mobile Device\");\r\nsm.uploadSignalsTable(\"Mobile Device\");\r\n```\r\n\r\nTo know when the data are upload, it is needed to run within a thread the function\r\nisProcessFinished(). An example of how to do this follows:\r\n\r\n``` java\r\nHandler mHandler = new Handler();\r\nmHandler.post(isFinished);\r\nRunnable isFinished = new Runnable(){\r\n\t@Override\r\n\tpublic void run() {\r\n\t\tif(rsm.isProcessFinished()){\r\n\t\t\tToast.makeText(getActivity(), \"Uploading completed\", Toast.LENGTH_LONG).show();\r\n}\r\n\t\telse\r\n\t\t\tmHandler.postDelayed(this, 1000);\r\n\t}\r\n};\r\n\r\n```\r\n\r\nOnce all the data are uploaded, the thread responsible for the uploading must be\r\nstopped, to save the waste of resources.\r\n\r\n``` java\r\nsm.finishProcess();\r\n```\r\n\r\nTo finish, according to users preferences, the WiFi connection could be turn off.\r\n``` java\r\nsysm.setWifiEnabled(false, getApplicationContext());\r\n```\r\n\r\nTo upload the local database, some PHP scripts are necessaries, provided along\r\nwith the framework. It is just a simple implementation, different scripts could be used, but the framework user must be careful with the scripts name and the paths where these are located. By default, if the user does not change scripts names or paths, the files get _last ID.php, DB config.php, insert mobile metadata.php, insert mobile signals.php, insert mobile units.php, insert shimmer metadata.php, insert shimmer signals.php_ and _insert shimmer units.php_ must be located in a path where can be accessible by the address _http://serverIP/nameFile.php_ (for example, in the directory Htdocs for XAMPP).\r\n\r\nConsequently, if the user wants to use different scripts or just for server reasons\r\nneeds to change their path, it can be achieved by means of the following functions: _set-\r\nMobileUnitsPath(String path), setMobileSignalsPath(String path), setMobileMetadata-\r\nPath(String path), setShimmerUnitsPath(String path), setShimmerSignalsPath(String\r\npath), setShimmerMetadataPath(String path)_ and _setLastIDPath(String path)_.\r\n\r\n### Visualization Manager\r\n\r\nSince it is a singleton class, first it is necessary to get the instance:\r\n\r\n``` java\r\nVisualizationManager vm = VisualizationManager.getInstance();\r\n```\r\n\r\nThen, a graph must be created. A unique name to the graph and its type (Line or\r\nBars) must be selected. The UI context must also be indicated.\r\n\r\n``` java\r\nvm.addGraph(\"graph\", GraphType.LINE, getApplicationContext());\r\n```\r\nNow, it depends on the approach desired, either online or offline. Here, both of them\r\nare explained.\r\n\r\n- Offline\r\n\t\r\n  To create a series, first it is necessary to create an array with the values of the Y\r\ncoordinates. For this example, the Sine of a set of numbers will be used:                  \t\r\n\r\n\t``` java\r\n\tfloat[] array = new float[250];\r\n\tfloat a = 0;\r\n    for (int i = 0; i < 250; i++) {\r\n\t\ta += 0.2;\r\n\t\tarray[i] = (float) Math.sin(a);\r\n\t}\r\n\t```\r\n    \r\n    To introduce the data into the graph, the following procedure must be used:\r\n    ``` java\r\nvm.addSerie(\"graph\", \"Sin\", array);\r\n```\r\nor\r\n\r\n  ``` java\r\n  vm.addSerie(\"graph\", \"Sin\", array, Color.BLUE, 1, \"Sin from 0 to 250\");\r\n  ```\r\nA series can be introduced with a description. To show it, one must activate the\r\noption. Its alignment in the graph can be set as well:\r\n``` java\r\nvm.setShowLegend(\"graph\", true);\r\nvm.setLegendAlign(\"graph\", LegendAlign.TOP);\r\n```\r\nThe graph must be included in a layout In order to be painted:\r\n```\r\nLinearLayout layout = (LinearLayout) findViewById(R.id.graph);\r\nvm.paint(\"graph\", layout);\r\n```\r\nHorizontal and vertical labels are created automatically, but they can be set like\r\nthis:\r\n``` java\r\nString [] month = {\"January\", \"February\", \"March\", \"April\", \"May\",\r\n\"June\", \"July\", \"August\", \"Sept.\", \"Oct.\", \"Nov.\", \"Dec.\"};\r\nvm.setHorizontalLabels(\"graph\", month);\r\nvm.setVerticaltalLabels(\"graph\", month);\r\n```\r\n\r\n- Online\r\n\t\r\n    Like in the offine mode, it is necessary to add the graph into a layout:\r\n``` java\r\nLinearLayout layoutOnline = (LinearLayout)\r\nfindViewById(R.id.graphOnline);\r\nvm.paint(\"graph\", layoutOnline);\r\n```\r\nTo visualize online data, it is necessary indicate the set of sensors desired:\r\n``` java\r\nArrayList<SensorType> sensors = new ArrayList<SensorType>();\r\nsensors.add(SensorType.ACCELEROMETER_X);\r\nsensors.add(SensorType.ACCELEROMETER_Y);\r\nsensors.add(SensorType.ACCELEROMETER_Z);\r\nsensors.add(SensorType.GYROSCOPE_X);\r\nsensors.add(SensorType.GYROSCOPE_Y);\r\nsensors.add(SensorType.GYROSCOPE_Z);\r\nsensors.add(SensorType.MAGNETOMETER_X);\r\nsensors.add(SensorType.MAGNETOMETER_Y);\r\nsensors.add(SensorType.MAGNETOMETER_Z);\r\n```\r\nThe _scrollable_ feature of the graph MUST be activated. Otherwise online visualization\r\nwill NOT work:\r\n``` java\r\nvm.setScrollable(\"graph\", true);\r\n```\r\nNow it is the time to use the function, which does all the work, to visualize the\r\ndata:\r\n``` java\r\nvm.visualizationOnline(\"graph\", \"nameDevice\", sensors);\r\n```\r\nTo stop the visualization process, the following method may be used:\r\n``` java\r\nvm.stopVisualizationOnline(\"graph\", \"nameDevice\");\r\n```\r\nThere are some features that are advisable to set in order to get a better visualization\r\nin both modes:\r\n- Make the graph scalable (advisable for offine mode):\r\n``` java\r\nvm.setScalable(\"graph\", true);\r\n```\r\n- Set the init and the viewport (advisable for online mode):\r\n``` java\r\nvm.setViewPort(\"graph\", 1, 200);\r\n```\r\n- Set the values of the Y axis (advisable for both modes):\r\n``` java\r\nvm.setManualYAxisBounds(\"graph\", 10, -10);\r\n```\r\n\r\n### System Manager\r\n\r\nSystem Manager is a singleton class. Thus, to obtain the unique instance that could\r\nexists in an application it is necessary to use the getInstance function.\r\n``` java\r\nSystemManager sm = SystemManager.getInstance();\r\n```\r\n\r\n#### Services and Setup\r\n\r\nServices and Setup modules are quite simple to use. To perform a mobile call or to\r\nsend a text message it could be done like follows:\r\n``` java\r\nsm.call(number, activity);\r\nsm.sendSMS(number, message);\r\n```\r\n\r\nWhere number parameter is the mobile number to call or send a message and\r\nmessage the text message to be sent.\r\nThere are three kind of notifications which can be used as follow:\r\n``` java\r\nsm.sendSimpleNotification(title, text, notificationID, icon, context);\r\nPendingIntent contentIntent =\r\nPendingIntent.getActivity(getApplicationContext(), 0, Intent, 0);\r\nint flags = Notification.FLAG_AUTO_CANCEL;\r\nsm.sendComplexNotification(title, text, notificationId, icon, flags,\r\ncontentIntent, context);\r\nUri soundUri =\r\nRingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);\r\nsm.sendComplexNotificationCustomSound(title, text, notificationId, icon,\r\nflags, contentIntent, soundUri, context);\r\n```\r\n\r\nWhere _title_ parameter is the notification title, _text_ the text to be shown, _notificationId_ the notification ID, _icon_ a notification icon and context the application UI\r\ncontext. For the last two notification type, _contentIntent_ is the Intent which is run\r\nwhen the notifications are clicked on and flags parameters are the notifications \r\nflags available for user usage.\r\n\r\n_NOTE. The minimum Android SDK Version required is 10th so some flags belonging\r\nto newer Android SDK versions may do not work properly._\r\n\r\nThese same notifications may be scheduled. It is necessary to declare in the Android\r\nManifest the class ScheduledTask as a receiver.\r\n\r\n``` java\r\n<receiver android:name=\"systemManager.services.ScheduledTask\"/>\r\n```\r\n\r\n```\r\nsm.scheduledSimpleNotification(title, text, notificationID, icon, context,\r\ndate);\r\nsm.scheduledComplexNotification(title, text, notificationId, icon, flags,\r\ncontentIntent, context, date);\r\nsm.scheduledComplexNotificationCustomSound(title, text, notificationId, icon,\r\nflags, contentIntent, soundUri, context, date);\r\n```\r\n\r\nAll parameters play the same role than explained previously except _Date_. It is a\r\nCalendar type which indicates when the notification is scheduled. It is also possible to\r\nschedule an audio to be reroduced by this:\r\n``` java\r\nsm.scheduledAudio(path, context, date);\r\n```\r\nWhere _path_ is the files path, _context_ is the application UI context and _date_ is a\r\nCalendar type indicating when the audio is scheduled to be reproduced.\r\n\r\nTo turn on/off Wi-Fi or Bluetooth:\r\n``` java\r\nsm.setWifiEnabled(true/false, context);\r\nsm.setBluetooth(true/false);\r\n```\r\nThe first boolean parameter set the Wi-Fi/Bluetooth state and _context_ is the application\r\nUI context. Finally, the screen brightness could be adjust as follows:\r\n``` java\r\nsm.setScreenBrightness(brightness, activity)\r\n```\r\nThe parameter of _brightness_ is a float number between 0 and 1 (from dark to\r\nbright). It is also possible to set it to less than 0, which means that the user default\r\nscreen brightness is used.\r\n\r\n#### Guidelines\r\n\r\nThe manner of using any of the guidelines modules is slightly different. First, it is\r\nnecessary to obtain an instance of the class which will be used and once this is done,\r\njust use its functions.\r\n\r\n##### YouTube\r\n\r\nTo build the YouTube module has been necessary the YouTube Android Player API. To employ this API is compulsory to provide at least a _YoutubePlayerView_. The class where this functionality is developed must extends the _YouTubeBaseActivity_ and implements _YouTubePlayer.OnInitializedListener_.\r\n\r\nAn example of how to use the YouTube Guideline module is shown next:\r\n\r\nAt least the following fields need to be declared as class fields.\r\n\r\n``` java\r\nYouTubePlayerView youTubePlayerView; \r\nYouTubePlayer player;\r\nListView videosListView;\r\nYoutube youtube;\r\n```\r\n\r\nDeclaration and initialization:\r\n\r\n``` java\r\nsetContentView(R.layout.youtube_layout);\r\nplayer = null;\r\nYouTubePlayerView youtubePlayerView =\r\n(YouTubePlayerView)findViewById(R.id.youtube_view);\r\nyoutubePlayerView.initialize(KEY_DEVELOPER, this);\r\nsm = SystemManager.getInstance();\r\nyoutube = sm.getYoutubePlayer(getApplicationContext(), youtubePlayerView);\r\n```\r\n\r\nThe developer key is a variable that identifies the YouTube developer submitting\r\nan API request. In the case when only playing a YouTube video is wanted, it could be\r\ndone by:\r\n``` java\r\nyoutube.reproduceSingleVideoMode(URL);\r\n```\r\nThe _URL_ parameter is the YouTube video URL to be reproduced, that consists of\r\nthe last part of the video link.\r\n\r\nIt is also possible to reproduce YouTube playlist videos, selecting the video to be\r\nreproduced using a _listView_ view. In order to do this, it is necessary to have in the\r\ncurrent layout a _listView_ view.\r\n``` java\r\nListView videosListView = (ListView) findViewById(R.id.listListView);\r\nyoutube.reproducePlaylistMode(videosListView, R.layout.entry, R.id.textViewSuperior, \r\nR.id.textViewInferior, R.id.imageViewImage, playlistID);\r\n```\r\nThe parameter _entry_ is a layout with every entry format of the _listview_. _TextViewSuperior_, _TextViewInferior_ and _imageViewImage_ are fields with the title, description and thumbnail of a YouTube video. _PlaylistID_ is the ID of a list of YouTube videos. \r\n\r\nIt is also necessary to implement two abstract methods belonging to _YouTubePlayer.OnInitializedListener_.\r\n\r\n``` java\r\n@Override\r\npublic void onInitializationFailure(Provider arg0, YouTubeInitializationResult arg1) {\r\n\r\n\tToast.makeText(this, \"Oh dear, something terrible happened, sorry!\", Toast.LENGTH_SHORT).show();\t\t\r\n}\r\n\r\n@Override\r\npublic void onInitializationSuccess(Provider provider, YouTubePlayer playa, boolean wasRestored) {\r\n\t\t\r\n\tthis.player = playa;\r\n\tthis.player.setPlayerStyle(YouTubePlayer.PlayerStyle.MINIMAL);\t\t\r\n\t//Now that the player is initialized, we need to set it on our Youtube class\r\n\tyoutube.setPlayer(player);\r\n}\r\n```\r\n\r\n##### Audio\r\n\r\nThe Audio module has been developed using the Media Player Android API.\r\nTo utilize this module, the first thing to do is to obtain an instance of the Audio class.\r\n\r\n``` java\r\nAudio audioPlayer = sm.getAudioPlayer();\r\n```\r\nNow, to play a stored audio file in the mobile phone, this must be done:\r\n``` java\r\nString path = Environment.getExternalStorageDirectory() + \"/\" + \"song.mp3\";\r\naudioPlayer.loadFile(path);\r\naudioPlayer.prepare();\r\naudioPlayer.play();\r\n```\r\nMore functions are available, such as _pause_, _resume_, _getDuration_, etc. However,\r\nevery function of the MediaPlayer API may be used.\r\n\r\n##### Video\r\n\r\nThe Video module is based on the functionality provides by the _VideoView_ view. To reproduce a video which is stored in the mobile external card, the following\r\nshould be done:\r\n\r\n``` java\r\nsetContentView(R.layout.video_layout);\r\nVideoViewvideoHolder = (VideoView)findViewById(R.id.videoView);\r\nVideo video = sm.getVideoPlayer(videoHolder);\r\nString path = Enviroment.getExternalStorageDirectory() + \"/\" + \"video.mp4\";\r\nvideo.setVideoPath(path);\r\nvideo.play();\r\n```\r\n\r\nMore functions are available, such as pause or resume. Every function of the\r\n_VideoView_ class may be used.\r\n\r\n### Data Processing Manager\r\n\r\nSince it is a singleton class, first it is necessary to get the unique instance.\r\n``` java\r\nDataProcessingManager dpm = DataProcessingManager.getInstance();\r\n```\r\nIt is also necessary to initialize and set (for the acquisition module) the Storage\r\nvariable belonging to the RemoteStorageManager class called storage. This is done by:\r\n``` java\r\ndpm.createAndSetStorage(getApplicationContext());\r\n```\r\nNow it proceeds depending on the inference knowledge approach desired: online or\r\noffine.\r\n\r\n#### Offline\r\n\r\n##### Acquisition\r\n    \r\n   To show how the data acquisition is done, some devices and sensors where data\r\nare retrieved must be selected. For example, it is shown how to acquire the signals\r\naccelerometer X, accelerometer Y, accelerometer Z and timestamp of a given wearable\r\ndevice called \"Shimmer Chest\" and the gyroscope X, gyroscope Y, gyroscope Z,\r\nhumidity and timestamp of a portable mobile device called \"Mobile Device\".\r\n\r\n``` java\r\nArrayList<Pair<ArrayList<SensorType>, String>> sensorsAndDevices = new\r\nArrayList<Pair<ArrayList<SensorType>, String>>();\r\nArrayList<SensorType> sensors1 = new ArrayList<SensorType>();\r\nArrayList<SensorType> sensors2 = new ArrayList<SensorType>();\r\nsensors1.add(SensorType.ACCELEROMETER_X);\r\nsensors1.add(SensorType.ACCELEROMETER_Y);\r\nsensors1.add(SensorType.ACCELEROMETER_Z);\r\nsensors1.add(SensorType.TIMESTAMP);\r\nsensors2.add(SensorType.GYROSCOPE_X);\r\nsensors2.add(SensorType.GYROSCOPE_Y);\r\nsensors2.add(SensorType.GYROSCOPE_Z);\r\nsensors2.add(SensorType.HUMIDITY);\r\nsensors2.add(SensorType.TIMESTAMP);\r\nString nameDevice1 = \"Shimmer CHEST\";\r\nString nameDevice2 = \"Mobile Device\";\r\nPair<ArrayList<SensorType>, String> pair1 = new Pair(sensors1, nameDevice1);\r\nPair<ArrayList<SensorType>, String> pair2 = new Pair(sensors2, nameDevice2);\r\nsensorsAndDevices.add(pair1);\r\nsensorsAndDevices.add(pair2);\r\n``` \r\n    \r\n   Now that _sensorsAndDevices_ is ready, any Acquisition function may be used. To\r\nacquire all the selected data in the IDs range 100-500:\r\n``` java\r\ndpm.retrieveInformationByID(100, 500, sensorsAndDevices);\r\n```\r\nTo retrieve data belonging to the first existing session:\r\n``` java\r\ndpm.retrieveBySession(1, sensorsAndDevices);\r\n```\r\nTo retrieve data belonging to the first, second and third session:\r\n``` java\r\ndpm.retrieveInformationByIntervalSessions(1, 3, sensorsAndDevices);\r\n```\r\nTo retrieve the last 20 seconds of available data in the local database:\r\n``` java\r\ndpm.retrieveInformationLastSeconds(20, sensorsAndDevices);\r\n```\r\nRetrieving data using dates is slightly more complicated. An example of retrieving\r\nall the data streamed from the day 24th January 2014 at 22:00:00 hour to the day 25th\r\nJanuary 2014 at 16:00:00 follows. It is important to keep in mind that month value\r\ngoes in the interval [0-11]\r\n``` java\r\nTime start = new Time();\r\nstart.hour = 22;\r\nstart.minute = 0;\r\nstart.second = 0;\r\nstart.year = 2014;\r\nstart.month = 0;\r\nstart.monthDay = 24;\r\nTime end = new Time();\r\nend.hour = 16;\r\nend.minute = 0;\r\nend.second = 0;\r\nend.year = 2014;\r\nend.month = 0;\r\nend.monthDay = 25;\r\ndpm.retrieveInformationByDates(start, end, sensorsAndDevices);\r\n```\r\nTo retrieve all the information available:\r\n``` java\r\ndpm.retrieveAllInformation(sensorsAndDevices);\r\n```\r\n\r\n##### Pre-Processing\r\n\r\nFrom this point, it is assumed that the data has been already acquired and stored\r\nin the hash variable (which is defined in this manager). Thus, to calculate either the\r\n_Upsampling_ or the _Downsampling_, one just needs to do the following:\r\n``` java\r\ndpm.downSampling(2);\r\ndpm.upSampling(3);\r\n```\r\nThe result will be stored into the _hashProcessed_ variable, which is defined in this\r\nmanager.\r\n\r\n##### Segmentation\r\n\r\nTo make the segmentation, first it is necessary to get the devices' sample rate. For\r\nthis example, an array with false sample rates is created:\r\n\r\n``` java\r\nArrayList<Float> rates = new ArrayList<Float>();\r\nrates.add((float) 50.0);\r\nrates.add((float) 50.0);\r\nrates.add((float) 50.0);\r\n```\r\nThen, the windowing no overlap can be calculated as follow:\r\n``` java\r\ndpm.windowing_NoOverlap(DataType.Raw, (float) 2, rates);\r\nand the windowing overlap as follow:\r\ndpm.windowing_overlap(DataType.Raw, (float) 2.5, (float) 0.5, rates);\r\n```\r\n##### Features Extraction\r\n\r\nThe features must be defined in order to make the features extraction. These are\r\nsome features definitions:\r\n``` java\r\ndpm.addFeature(\"Device Shimmer 1\", SensorType.ACCELEROMETER_X,\r\nFeatureType.MAXIMUM);\r\ndpm.addFeature(\"Device Shimmer 2\", SensorType.ACCELEROMETER_Y,\r\nFeatureType.MINIMUM);\r\ndpm.addFeature(\"Device Mobile\", SensorType.ACCELEROMETER_Z,\r\nFeatureType.VARIANCE);\r\ndpm.addFeature(\"Device Shimmer 1\", SensorType.GYROSCOPE_Y,\r\nFeatureType.STANDARD_DEVIATION);\r\ndpm.addFeature(\"Device Shimmer 2\", SensorType.MAGNETOMETER_X,\r\nFeatureType.ZERO_CROSSING_RATE);\r\ndpm.addFeature(\"Device Mobile\", SensorType.MAGNETOMETER_Z,\r\nFeatureType.MEAN_CROSSING_RATE);\r\n```\r\nOwing to the previous steps, the features extraction can be done from different data:\r\n\r\n- From not processed data and not segmented:\r\n``` java\r\ndpm.feature_extraction(DataType.Raw, false, false);\r\n```\r\n- From processed data and not segmented:\r\n``` java\r\ndpm.feature_extraction(DataType.Processed, false, false);\r\n```\r\n- From not processed data and segmented:\r\n``` java\r\ndpm.feature_extraction(DataType.Raw, true, false);\r\n```\r\n- From processed and segmented data, using the uncompleted windows:\r\n``` java\r\ndpm.feature_extraction(DataType.Processed, true, true);\r\n```\r\n\r\n##### Classification\r\n\r\nThe way to use the Classification module does not change depending on the selected\r\napproach (offine or online). The first thing to do is to read a Weka file (arff format).\r\n\r\n``` java\r\ndpm.readFile(Environment.getExternalStorageDirectory(), \"example.arff\");\r\n```\r\nNow, test or training instances may be set. Also a summary of both train instances\r\nmay be obtained.\r\n``` java\r\ndpm.setTrainInstances();\r\ndpm.setTestInstances();\r\nString TrainSummary = dpm.getTrainInstancesSummary();\r\n```\r\nA model may be built with the _trainClassifier_ function. The first parameter is the\r\nclass attribute and usually is the last attribute. The second parameter is the classifier\r\ntype to be used, in this case J48 (Decision Tree). The _getAttributes_ function returns a\r\nlist of the existing Attributes.\r\n``` java\r\nint numAttributes = classification.getAttributes().size();\r\ndpm.trainClassifier(numAttributes - 1, classifierType.J48);\r\n```\r\nThe model may be directly loaded as well using the _loadModel_ method:\r\n``` java\r\ndpm.loadModel(classifier);\r\n```\r\nNow that the model has been built, this can be evaluated by the method _testClassifier_. A summary about the evaluation may be obtained by _getTestSummary_ method.\r\nThe confusion matrix is obtained using the _getTestConfusionMatrix_ function.\r\n``` java\r\ndpm.testClassifier();\r\nString summaryEvaluation = dpm.getTestSummary();\r\nString confusionMatrix = dpm.getConfusionMatrix();\r\n```\r\nTo convert features vector or features matrix coming from the Feature Extracture\r\nstage into Instances Weka objects, the methods _featureVectorToInstances_ and _featureMatrixToInstances_ are available.\r\n``` java\r\nInstances instances = dpm.featureVectorToInstances(featureVector);\r\nInstances instances = dpm.featureMatrixToInstances(featureMatrix);\r\n```\r\nTo clasify and unlabeled instance, there are two functions available: _classifyInstanceToDouble_ and _classifyInstanceToString_. For example, to classify the first instance of an Instances object called instances:\r\n``` java\r\nString label = dpm.classifyInstanceToString(instances.firstInstance());\r\nDouble label = dpm.classifyInstanceToDouble(instances.firstInstance());\r\n```\r\n\r\n#### Online\r\n\r\n##### Acquisition and Segmentation\r\n\r\nThese modules are not used in the online inference knowledge process, due to that\r\nthe Communication Manager is the one which provides the data through windows with\r\na determinate size.\r\n\r\n##### Pre-Processing, Feature Extraction, and Classification\r\n\r\nTo make the online knowledge inference, it is necessary to define the features to\r\nbe extracted. The classification model and the class attribute must be defined as well.\r\nThe previous section, Offine knowledge inference, shows how to do it.\r\nIn order to execute the knowledge inference as a sequence, all the steps are defined under one function:\r\n\r\n``` java\r\ndpm.inferenceOnline(2, sensorsAndDevices, null, 0, 1);\r\n```\r\n\r\nThe last parameter indicates which kind the class attribute is (and in consequence the\r\nvalue returned): String or Double. In case the last parameter is 0, the returned value\r\nwill be a String and will be stored in the _stringClassified variable_ (which is defuned in this manager). In case the last parameter is 1 (like in the example), the returned value will be Double and will be stored in the _doubleClassified_ variable (which is also defined in this manager).\r\n\r\nThere is also another function for the online knowledge inference:\r\n``` java\r\ndpm.inferenceOnline(2, sensorsAndDevices, null, 0, 1, mHandler);\r\n```\r\n\r\n## Contribution guidelines\r\n\r\nHow can you help mHealthDroid to be a more completed tool? Here we propose you some ideas!\r\n\r\n- Adding new biomedical devices drivers would be awesome! The possibility of using more and more biomedical devices makes mHealthDroid a tool more accesible for everybody!\r\n\r\n- To improve the data visualization including more functionalities. Representing online visualization for different devices in the same graph would be cool!\r\n\r\n- Extending the pre-processing module of the Data Processing Manager by adding more methods (downsampling and upsampling are already provided).\r\n\r\n- Extending the features extraction module of the Data Processing Manager by adding new features (mean, variance, standard deviation, zero crossing rate, mean crossing rate, maximum and minimum already provided).\r\n\r\n- To extend the funcionalities for the remote storage, making possible the data transference in both ways. ¿Cloud services for high performance computacion?\r\n\r\n- To extend the guidelines functionalities. For example, Audio and Video modules encapsulates the basic functionalities of the Android Media Player API and the VideoView Android class. Adding extra functionalities would help to a more complete experience.\r\n\r\n- To add more functionalities to manage the mobile aspects.\r\n\r\n- To update notifications to the new ones provided by the last Android versions. Notifications implementation to this day, uses the functions provided for the Android SDK Version 10.\r\n\r\nMore contribution ideas will be added soon.\r\n\r\n\r\n## Community\r\n\r\nHow can you keep track of the development and news of mHealthDroid? Follow us in our <a href=\"https://twitter.com/mhealthdroid\">twitter</a>\r\n\r\n## Team Members\r\n\r\n### Authors\r\n\r\nRafael García\r\n\r\n* http://github.com/rafagf\r\n* Email: rafagarfer@gmail.com \r\n\r\nAlejandro Sáez\r\n\r\n* http://github.com/alsafer\r\n* Email: alejandrosaez3@gmail.com\r\n\r\n### Original Idea and Project Coordinator\r\n\r\nDr. Oresti Baños\r\n\r\n* _Research Center for Information and Communication Technology University of Granada (CITIC-UGR)_\r\n* Email: oresti.bl@gmail.com\r\n\r\n### Collaborators\r\n\r\nProf. Juan Antonio Holgado\r\n\r\n* _University of Granada (UGR)_\r\n* Email: jholgado@ugr.es\r\n\r\n## Where can I get help?\r\n\r\nYou can get any help you need getting in contact with any of the authors. We are looking forward to help you!\r\n\r\n## Inspiration and motivation\r\n\r\nThis project is an original idea. The project was initiated and developed as part of the MsC thesis (Computer Science) of the authors at University of Granada (UGR) . \r\n\r\nAfter evaluation of the state-of-the-art in mobile health we ended up with the conclusion that there exist multiple wearable health devices (most of which are becoming commercial), biomedical apps and also biomedical and mobile frameworks. However, no biomedical mobile framework exists in a broad sense to the best of our knowledge. Although there are some frameworks devised for particular clinical problems, they mainly support data acquisition, visualization and broadcasting. Powerful health applications should incorporate these features plus many others such as local and remote storage, guidelines, recommenders notifications or knowledge inference among others, and not be limited to a particular biomedical device.\r\n\r\n## Copyright and license\r\n\r\nProject released under the license GPL V.3.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}